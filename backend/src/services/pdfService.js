const PDFDocument = require("pdfkit");
const fs = require("fs");
const path = require("path");

class PDFService {
  constructor() {
    // Ensure uploads directory exists
    this.uploadsDir = path.join(__dirname, "../../uploads");
    if (!fs.existsSync(this.uploadsDir)) {
      fs.mkdirSync(this.uploadsDir, { recursive: true });
    }
  }

  async generateAIAnalysisPDF(analysisData, patientData, userData) {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument({
          size: "A4",
          margin: 50,
          info: {
            Title: `AI Analysis Report - ${analysisData.fileName}`,
            Author: `${userData.firstName} ${userData.lastName}`,
            Subject: "Medical Document AI Analysis",
            Keywords: "AI, Medical, Analysis, Report",
            CreationDate: new Date(),
          },
        });

        const fileName = `ai-analysis-${Date.now()}.pdf`;
        const filePath = path.join(this.uploadsDir, fileName);
        const stream = fs.createWriteStream(filePath);

        doc.pipe(stream);

        // Header
        doc
          .fontSize(24)
          .font("Helvetica-Bold")
          .fillColor("#1f2937")
          .text("AI Medical Analysis Report", { align: "center" });

        doc.moveDown(0.5);

        // Patient Information Section
        doc
          .fontSize(16)
          .font("Helvetica-Bold")
          .fillColor("#374151")
          .text("Patient Information", { underline: true });

        doc.fontSize(10).font("Helvetica").fillColor("#6b7280");

        doc.text(`Name: ${patientData.firstName} ${patientData.lastName}`);
        doc.text(`Patient ID: ${patientData.patientId}`);
        doc.text(`Age: ${this.calculateAge(patientData.dateOfBirth)} years`);
        doc.text(`Gender: ${patientData.gender}`);
        doc.text(`Date of Analysis: ${new Date().toLocaleDateString()}`);
        doc.text(`Analyzed by: ${userData.firstName} ${userData.lastName}`);

        doc.moveDown();

        // Document Information
        doc
          .fontSize(16)
          .font("Helvetica-Bold")
          .fillColor("#374151")
          .text("Document Information", { underline: true });

        doc.fontSize(10).font("Helvetica").fillColor("#6b7280");

        doc.text(`Document Name: ${analysisData.fileName}`);
        doc.text(`Analysis ID: ${analysisData.analysisId}`);
        doc.text(
          `Confidence Score: ${(
            analysisData.analysisResult.confidence * 100
          ).toFixed(1)}%`
        );
        doc.text(
          `Processing Time: ${Math.round(
            analysisData.analysisResult.processingTime / 1000
          )} seconds`
        );

        doc.moveDown();

        // AI Analysis Results
        doc
          .fontSize(16)
          .font("Helvetica-Bold")
          .fillColor("#374151")
          .text("AI Analysis Results", { underline: true });

        doc.fontSize(10).font("Helvetica").fillColor("#1f2937");

        // Format and add the analysis summary with proper markdown formatting
        const summary =
          analysisData.analysisResult.rawResponse ||
          analysisData.analysisResult.summary;
        if (summary) {
          const formattedSummary = this.formatMarkdownForPDF(summary);
          doc.text(formattedSummary, {
            align: "justify",
            lineGap: 2,
          });
        }

        doc.moveDown();

        // Key Findings
        if (
          analysisData.analysisResult.keyFindings &&
          analysisData.analysisResult.keyFindings.length > 0
        ) {
          doc
            .fontSize(14)
            .font("Helvetica-Bold")
            .fillColor("#374151")
            .text("Key Findings", { underline: true });

          doc.fontSize(10).font("Helvetica").fillColor("#1f2937");

          analysisData.analysisResult.keyFindings.forEach((finding, index) => {
            doc.text(`• ${finding}`, { indent: 20 });
          });

          doc.moveDown();
        }

        // Recommendations
        if (
          analysisData.analysisResult.recommendations &&
          analysisData.analysisResult.recommendations.length > 0
        ) {
          doc
            .fontSize(14)
            .font("Helvetica-Bold")
            .fillColor("#374151")
            .text("Recommendations", { underline: true });

          doc.fontSize(10).font("Helvetica").fillColor("#1f2937");

          analysisData.analysisResult.recommendations.forEach(
            (recommendation, index) => {
              doc.text(`• ${recommendation}`, { indent: 20 });
            }
          );

          doc.moveDown();
        }

        // Footer
        doc
          .fontSize(8)
          .font("Helvetica")
          .fillColor("#9ca3af")
          .text("Generated by MedLens AI System", { align: "center" });

        doc.end();

        stream.on("finish", () => {
          resolve({
            filePath,
            fileName,
            fileSize: fs.statSync(filePath).size,
          });
        });

        stream.on("error", (error) => {
          reject(error);
        });
      } catch (error) {
        reject(error);
      }
    });
  }

  formatTextForPDF(text) {
    // Clean up the text for PDF formatting
    return text
      .replace(/<[^>]*>/g, "") // Remove HTML tags
      .replace(/```[\s\S]*?```/g, "") // Remove code blocks
      .replace(/`([^`]+)`/g, "$1") // Remove inline code
      .replace(/^---$/gm, "") // Remove horizontal rules
      .replace(/\*+/g, "") // Remove asterisks
      .replace(/\n{3,}/g, "\n\n") // Limit consecutive newlines
      .trim();
  }

  formatMarkdownForPDF(markdownText) {
    // Enhanced markdown formatting for PDF
    let formatted = markdownText
      // Remove HTML tags
      .replace(/<[^>]*>/g, "")
      // Remove code blocks
      .replace(/```[\s\S]*?```/g, "")
      // Remove inline code
      .replace(/`([^`]+)`/g, "$1")
      // Remove horizontal rules
      .replace(/^---$/gm, "")
      // Remove extra asterisks
      .replace(/\*+/g, "")
      .trim();

    // Process headers
    formatted = formatted
      .replace(/^#\s+(.+)$/gm, "\n$1\n") // H1
      .replace(/^##\s+(.+)$/gm, "\n$1\n") // H2
      .replace(/^###\s+(.+)$/gm, "\n$1\n") // H3
      .replace(/^####\s+(.+)$/gm, "\n$1\n"); // H4

    // Process bullet points
    formatted = formatted
      .replace(/^[-*•]\s+(.+)$/gm, "• $1") // Convert to bullet points
      .replace(/^\d+\.\s+(.+)$/gm, "$1"); // Remove numbered list formatting

    // Process emphasis
    formatted = formatted
      .replace(/\*\*(.+?)\*\*/g, "$1") // Bold
      .replace(/\*(.+?)\*/g, "$1"); // Italic

    // Process blockquotes
    formatted = formatted.replace(/^>\s+(.+)$/gm, "$1"); // Remove blockquote formatting

    // Clean up spacing
    formatted = formatted
      .replace(/\n{3,}/g, "\n\n") // Limit consecutive newlines
      .replace(/\s{2,}/g, " ") // Remove multiple spaces
      .trim();

    return formatted;
  }

  calculateAge(dateOfBirth) {
    const birthDate = new Date(dateOfBirth);
    const today = new Date();
    let age = today.getFullYear() - birthDate.getFullYear();
    const monthDiff = today.getMonth() - birthDate.getMonth();

    if (
      monthDiff < 0 ||
      (monthDiff === 0 && today.getDate() < birthDate.getDate())
    ) {
      age--;
    }

    return age;
  }

  async uploadPDFToR2(pdfPath, fileKey) {
    try {
      const fileBuffer = fs.readFileSync(pdfPath);

      const params = {
        Bucket: "medlens-documents",
        Key: fileKey,
        Body: fileBuffer,
        ContentType: "application/pdf",
        Metadata: {
          originalname: path.basename(pdfPath),
          contenttype: "application/pdf",
        },
      };

      // Use the same AWS S3 configuration as the upload routes
      const AWS = require("aws-sdk");
      const s3 = new AWS.S3({
        endpoint: process.env.R2_ENDPOINT,
        accessKeyId: process.env.R2_ACCESS_KEY_ID,
        secretAccessKey: process.env.R2_SECRET_ACCESS_KEY,
        region: "auto", // R2 doesn't use regions like S3
        signatureVersion: "v4",
      });

      await s3.upload(params).promise();

      // Clean up local file
      fs.unlinkSync(pdfPath);

      return {
        success: true,
        fileKey,
        fileSize: fileBuffer.length,
      };
    } catch (error) {
      console.error("Error uploading PDF to R2:", error);
      throw error;
    }
  }
}

module.exports = PDFService;
